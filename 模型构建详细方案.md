# 2025 MCM C题：奥运奖牌预测 - 详细建模方案

## 模型1：时间序列预测模型

### 1.1 ARIMA模型

**数学表达：**
```
ARIMA(p,d,q): 
  (1 - Σφᵢ·Lⁱ)·(1-L)ᵈ·Yₜ = (1 + Σθⱼ·Lʲ)·εₜ

其中：
  p = 自回归阶数
  d = 差分阶数  
  q = 移动平均阶数
  L = 滞后算子
  εₜ ~ N(0, σ²)
```

**参数选择：**
- 使用AIC/BIC准则
- 网格搜索：p∈[0,5], d∈[0,2], q∈[0,5]

**Python实现：**
```python
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# 1. 平稳性检验
from statsmodels.tsa.stattools import adfuller
result = adfuller(df['medals'])
print(f'ADF Statistic: {result[0]}')
print(f'p-value: {result[1]}')

# 2. ACF/PACF图确定参数
fig, axes = plt.subplots(1, 2, figsize=(12,4))
plot_acf(df['medals'], lags=20, ax=axes[0])
plot_pacf(df['medals'], lags=20, ax=axes[1])

# 3. 模型训练
model = ARIMA(train_data, order=(2,1,2))
fitted_model = model.fit()

# 4. 预测
forecast = fitted_model.forecast(steps=1)
```

### 1.2 Prophet模型

**优势：**
- 自动处理季节性
- 鲁棒处理缺失值
- 可解释的趋势分解

**模型组件：**
```
y(t) = g(t) + s(t) + h(t) + εₜ

其中：
  g(t) = 趋势项（分段线性或逻辑增长）
  s(t) = 周期性项（傅里叶级数）
  h(t) = 节假日效应
  εₜ = 误差项
```

**Python实现：**
```python
from prophet import Prophet

# 准备数据
df_prophet = pd.DataFrame({
    'ds': dates,  # 日期
    'y': medals   # 奖牌数
})

# 添加额外回归变量
df_prophet['gdp'] = gdp_data
df_prophet['population'] = pop_data

# 训练模型
model = Prophet(
    yearly_seasonality=True,
    changepoint_prior_scale=0.05
)
model.add_regressor('gdp')
model.add_regressor('population')
model.fit(df_prophet)

# 预测
future = model.make_future_dataframe(periods=1, freq='4Y')
future['gdp'] = future_gdp
future['population'] = future_pop
forecast = model.predict(future)
```

### 1.3 LSTM深度学习模型

**网络架构：**
```
Input Layer (sequence_length, features)
    ↓
LSTM Layer 1 (128 units, return_sequences=True)
    ↓
Dropout (0.2)
    ↓
LSTM Layer 2 (64 units)
    ↓
Dropout (0.2)
    ↓
Dense Layer (32 units, ReLU)
    ↓
Output Layer (1 unit, Linear)
```

**Python实现：**
```python
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# 数据准备
def create_sequences(data, seq_length=3):
    X, y = [], []
    for i in range(len(data) - seq_length):
        X.append(data[i:i+seq_length])
        y.append(data[i+seq_length])
    return np.array(X), np.array(y)

X_train, y_train = create_sequences(train_data, seq_length=3)
X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))

# 构建模型
model = Sequential([
    LSTM(128, return_sequences=True, input_shape=(3, 1)),
    Dropout(0.2),
    LSTM(64),
    Dropout(0.2),
    Dense(32, activation='relu'),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse', metrics=['mae'])

# 训练
history = model.fit(
    X_train, y_train,
    epochs=100,
    batch_size=32,
    validation_split=0.2,
    callbacks=[
        tf.keras.callbacks.EarlyStopping(patience=10),
        tf.keras.callbacks.ReduceLROnPlateau(factor=0.5, patience=5)
    ]
)

# 预测
X_test = test_data[-3:].reshape((1, 3, 1))
prediction = model.predict(X_test)
```

---

## 模型2：机器学习回归模型

### 2.1 特征工程

**特征类别：**

**1. 历史特征**
```python
# 滞后特征
df['medals_lag1'] = df.groupby('country')['medals'].shift(1)
df['medals_lag2'] = df.groupby('country')['medals'].shift(2)
df['medals_lag3'] = df.groupby('country')['medals'].shift(3)

# 滚动统计
df['medals_ma3'] = df.groupby('country')['medals'].rolling(3).mean()
df['medals_std3'] = df.groupby('country')['medals'].rolling(3).std()

# 趋势特征
df['medals_growth'] = df.groupby('country')['medals'].pct_change()
df['medals_acceleration'] = df['medals_growth'].diff()
```

**2. 经济特征**
```python
# GDP相关
df['gdp_per_capita'] = df['gdp'] / df['population']
df['gdp_growth'] = df.groupby('country')['gdp'].pct_change()
df['gdp_log'] = np.log(df['gdp'] + 1)

# 体育投资
df['sports_investment_per_capita'] = df['sports_budget'] / df['population']
df['investment_growth'] = df.groupby('country')['sports_budget'].pct_change()
```

**3. 比赛特征**
```python
# 项目数量
df['events_participated'] = df['events_count']
df['events_ratio'] = df['events_participated'] / df['total_events']

# 运动员数量
df['athletes_count'] = df['num_athletes']
df['athletes_per_event'] = df['athletes_count'] / df['events_participated']
```

**4. 交互特征**
```python
# 经济×人口
df['gdp_pop_interaction'] = df['gdp'] * df['population']

# 投资×项目
df['investment_events'] = df['sports_budget'] * df['events_participated']

# 主办国效应
df['host_country'] = (df['country'] == df['host']).astype(int)
df['host_effect'] = df['host_country'] * df['medals_lag1']
```

### 2.2 XGBoost模型

**超参数：**
```python
params = {
    'objective': 'reg:squarederror',
    'max_depth': 6,
    'learning_rate': 0.05,
    'n_estimators': 500,
    'subsample': 0.8,
    'colsample_bytree': 0.8,
    'min_child_weight': 3,
    'gamma': 0.1,
    'reg_alpha': 0.1,
    'reg_lambda': 1.0
}
```

**完整实现：**
```python
from xgboost import XGBRegressor
from sklearn.model_selection import GridSearchCV, cross_val_score

# 特征选择
features = [
    'medals_lag1', 'medals_lag2', 'medals_lag3',
    'medals_ma3', 'medals_growth',
    'gdp_per_capita', 'gdp_growth',
    'sports_investment_per_capita',
    'events_participated', 'athletes_count',
    'host_country', 'gdp_pop_interaction'
]

X = df[features]
y = df['medals']

# 训练集/测试集划分
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# 模型训练
model = XGBRegressor(**params)
model.fit(
    X_train, y_train,
    eval_set=[(X_test, y_test)],
    early_stopping_rounds=50,
    verbose=False
)

# 特征重要性
importance = pd.DataFrame({
    'feature': features,
    'importance': model.feature_importances_
}).sort_values('importance', ascending=False)

print(importance)

# 预测
predictions = model.predict(X_test)

# 评估
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
mae = mean_absolute_error(y_test, predictions)
rmse = np.sqrt(mean_squared_error(y_test, predictions))
r2 = r2_score(y_test, predictions)

print(f'MAE: {mae:.2f}')
print(f'RMSE: {rmse:.2f}')
print(f'R²: {r2:.3f}')
```

### 2.3 模型融合（Ensemble）

**Stacking策略：**
```python
from sklearn.ensemble import StackingRegressor
from sklearn.linear_model import Ridge

# Base models
base_models = [
    ('xgb', XGBRegressor(**params)),
    ('lgb', LGBMRegressor(**lgb_params)),
    ('rf', RandomForestRegressor(**rf_params))
]

# Meta model
meta_model = Ridge(alpha=1.0)

# Stacking
stacking_model = StackingRegressor(
    estimators=base_models,
    final_estimator=meta_model,
    cv=5
)

stacking_model.fit(X_train, y_train)
stacking_pred = stacking_model.predict(X_test)
```

**加权平均：**
```python
# 根据验证集表现确定权重
weights = {
    'arima': 0.15,
    'prophet': 0.15,
    'lstm': 0.20,
    'xgboost': 0.25,
    'lightgbm': 0.15,
    'stacking': 0.10
}

final_prediction = (
    weights['arima'] * arima_pred +
    weights['prophet'] * prophet_pred +
    weights['lstm'] * lstm_pred +
    weights['xgboost'] * xgb_pred +
    weights['lightgbm'] * lgb_pred +
    weights['stacking'] * stacking_pred
)
```

---

## 模型3：优化调整模型

### 3.1 主办国效应调整

**历史数据分析：**
```python
# 计算历史主办国奖牌增幅
host_effect = df[df['host_country']==1].groupby('country').apply(
    lambda x: (x['medals'] / x['medals_lag1']).mean()
)

print(f"平均主办国效应: {host_effect.mean():.2%}")
# 输出: 平均主办国效应: 18.5%
```

**调整公式：**
```
Medals_2028_USA = Baseline_Prediction × (1 + host_effect)
                = Baseline_Prediction × 1.185
```

### 3.2 项目变化调整

**新增/删除项目影响：**
```python
# 假设2028年新增5个项目
new_events = 5
usa_event_medal_rate = 0.12  # 美国历史上每项目平均奖牌数

additional_medals = new_events * usa_event_medal_rate
adjusted_prediction = baseline_prediction + additional_medals
```

### 3.3 不确定性量化（贝叶斯方法）

**贝叶斯线性回归：**
```python
import pymc3 as pm

with pm.Model() as model:
    # 先验分布
    alpha = pm.Normal('alpha', mu=0, sd=10)
    beta = pm.Normal('beta', mu=0, sd=10, shape=len(features))
    sigma = pm.HalfNormal('sigma', sd=5)
    
    # 似然函数
    mu = alpha + pm.math.dot(X_train, beta)
    y_obs = pm.Normal('y_obs', mu=mu, sd=sigma, observed=y_train)
    
    # MCMC采样
    trace = pm.sample(2000, tune=1000, return_inferencedata=False)

# 预测分布
with model:
    pm.set_data({'X': X_test})
    posterior_pred = pm.sample_posterior_predictive(trace)

# 95%置信区间
lower = np.percentile(posterior_pred['y_obs'], 2.5, axis=0)
upper = np.percentile(posterior_pred['y_obs'], 97.5, axis=0)
```

---

## 模型验证与评估

### 回测验证

**时间序列交叉验证：**
```python
from sklearn.model_selection import TimeSeriesSplit

tscv = TimeSeriesSplit(n_splits=5)
scores = []

for train_idx, test_idx in tscv.split(X):
    X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
    y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]
    
    model.fit(X_train, y_train)
    pred = model.predict(X_test)
    
    mae = mean_absolute_error(y_test, pred)
    scores.append(mae)

print(f"平均MAE: {np.mean(scores):.2f} ± {np.std(scores):.2f}")
```

### 敏感性分析

**单因素敏感性：**
```python
def sensitivity_analysis(base_features, feature_name, variation_range):
    results = []
    
    for delta in variation_range:
        features_copy = base_features.copy()
        features_copy[feature_name] *= (1 + delta)
        
        pred = model.predict(features_copy)
        results.append({
            'delta': delta,
            'prediction': pred[0],
            'change': (pred[0] - base_pred) / base_pred
        })
    
    return pd.DataFrame(results)

# 测试GDP变化的影响
gdp_sensitivity = sensitivity_analysis(
    base_features, 
    'gdp_per_capita', 
    np.linspace(-0.2, 0.2, 21)
)

# 可视化
plt.plot(gdp_sensitivity['delta'], gdp_sensitivity['change'])
plt.xlabel('GDP变化率')
plt.ylabel('奖牌预测变化率')
plt.title('GDP敏感性分析')
```

---

**下一步：开始数据分析和模型实现！**
